---
layout: post
title: "Day 3 - Linked Lists Part 1"
date: 2022-02-21
catagories: linked lists
---
## Introduction
I decided to start my jouney with data structures and algorithms with Linked Lists. Why? Because linked lists have always been a thorn in my side. One of my weak spots when it comes to programming. So for the next few days I want to focus on problems with linked lists and really understand how to solves problems with them.


## What is a linked list
Basically a linked list is a chain of **Nodes** and each node in a linked list points to one other node. The **head** is the first node and no other node points to it. The **tail** is the last node and it points to null. So for example a linked list might look something like this

```
0 -> 1 -> 2 -> 3 -> null
```

with 0 being the head node and 3 being the tail. This specific linked list is known as a singly linked list as each node has one and only one pointer.

## Doubly Linked List

Now expanding on singly linked list we have doubly linked list which point to the nodes **before and after** them. So the structure will look like

```
0 <-> 1 <-> 2 <-> 3 <-> null
```

Lets look at how we can implement a doubly linked list using JavaScript

### JavaScript Implementation of Doubly Linked List

```js

// Lets define a node class as we need the node data structure to implement a linked list of any type
class Node{
    constructor(value){
        this.value = value;
        this.prev = null; // In a singly linked list we can omit this for our node class
        this.next = null;
    }
}

class DoublyLinkedList{
    constructor() {
        this.head = null;
        this.tail = null;
    }

    setHead(node){
        if(this.head === null){
            this.head = node;
            this.tail = node;
            return;
        }
        this.insertBefore(this.head, node); 
    }

    setTail(node){
        if(this.tail === null){
            this.setHead(node); // having no tail is the same as having no head
            return;
        }
        this.insertAfter(this.tail, node);
    }

    insertBefore(node, nodeToInsert){
        if(nodeToInsert === this.head && nodeToInsert === this.tail) return;//edge case for list with 1 node
        this.remove(nodeToInsert);
        nodeToInsert.prev = node.prev;
        nodeToInsert.next = node;
        if(node.prev === null){        //checking if node is the head
            this.head = nodeToInsert;
        } else {
            node.prev.next = nodeToInsert;
        }
        node.prev = nodeToInsert;
    }

    insertAfter(node, nodeToInsert){
        if(nodeToInsert === this.head && nodeToInsert == this.tail) return;
        this.remove(nodeToInsert);
        nodeToInsert.prev = node;
        nodeToInsert.next = node.next;
        if(node.next === null){         //checking if node is the tail
            this.tail = nodeToInsert;
        } else {
            node.next.prev = nodeToInsert;
        }
        node.next = nodeToInsert;
    }

    insertAtPosition(position, nodeToInsert){
        if(position === 1){
            this.setHead(nodeToInsert);
            return;
        }
        let node = this.head;
        let currentPosition = 1;
        while(node !== null && currentPosition++ !== position){ //move to the node right before the position
            node = node.next;
        }
        if(node !== null){      //if the node is null then we have gotten to the tail of our list
            this.insertBefore(node, nodeToInsert);
        } else {
            this.setTail(nodeToInsert);
        }
    }

    containsNodeWithValue(value){
        let node = this.head;
        while(node !== null && node.value !== value){
            node = node.next;
        }
        return node !== null; //will return false if it goes past the tail i.e. null
    }

    removeNodesWithValue(value){
        let node = this.head;
        while (node !== null){
            const nodeToRemove = node;
            node = node.next;
            if(nodeToRemove.value === value){
                this.remove(nodeToRemove);
            }
        }
    }

    remove(node){
        if(node === this.head){
            this.head = this.head.next;
        }
        if(node === this.tail){
            this.tail = this.tail.prev;
        }
        this.removeBindings(node);
    }

    // This is a super important method and is a good starting point for pointer manipulation in linked list
    removeBindings(node){
        if(node.prev !== null){
            node.prev.next = node.next;
        }
        if(node.next !== null){
            node.next.prev = node.prev;
        }
        node.prev == null;
        node.next == null;
    }
}

```

and that's it - a doubly linked list in javascript. I think creating these structures from scratch has really helped me understand the very basics of them.

## Key Points
 I think one of the biggest things I learned with linked list is iterating through them. The basic structure of iterrating through a linked list is as follows

 1. set a new node to equal the head
 2. loop while node !== null or in some cases while node.next !== null
 3. set node = node.next

In code that would look like this

```js
loopThroughList(){
    let node = this.head;
    while(node !== null){
        node = node.next;
    }
}

```

For some reason this has been one of the most confusing aspects for linked list for me even though it is fairly simple. However, I think I'm getting the hang of it.

Another note is just to think about what pointers need to be changed depending on the method. It can get really confusing but if I take my time and visualize I think it will be okay.

## Conclusion
That's all I have for today. There's a bunch more of linked list that I did do, but I want to go back over them as review in the next couple days as I take on more questions. Anyways, cheers!!